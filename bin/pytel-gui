#!/usr/bin/env python3.6
import argparse
import inspect
import logging
import pprint
import sys
from threading import RLock, Event, Thread
import re
import time
import os
from PyQt5 import QtWidgets, QtCore, QtGui
from PyQt5.QtCore import pyqtSignal
from astropy.time import Time
from colour import Color

from pytel.comm import RemoteException
from pytel.comm.xmpp import XmppComm
from pytel.events import LogEvent
from pytel.events.clientconnected import ClientConnectedEvent
from pytel.events.clientdisconnected import ClientDisconnectedEvent
from pytel_gui import Ui_Supervisor, LogModel, LogModelProxy


class Supervisor(QtWidgets.QMainWindow, Ui_Supervisor):
    add_log = pyqtSignal(list)
    add_command_log = pyqtSignal(str)
    client_list_changed = pyqtSignal()

    def __init__(self, comm, log_latency=2, **kwargs):
        QtWidgets.QMainWindow.__init__(self)
        self.setupUi(self)

        # store comm client
        self.comm = comm

        # closing
        self.closing = Event()

        # logs
        self.log_model = LogModel()
        self.add_log.connect(self.log_model.add_entry)
        self.log_proxy = LogModelProxy()
        self.log_proxy.setSourceModel(self.log_model)
        self.tableLog.setModel(self.log_proxy)
        self.log_model.rowsInserted.connect(lambda: QtCore.QTimer.singleShot(0, self.tableLog.scrollToBottom))
        self.log_model.rowsInserted.connect(self._resize_log_table)
        self.listLogClients.itemChanged.connect(self._log_client_changed)

        # commands
        self.command_model = None
        self.command_regexp = re.compile(r'(\w+)\.(\w+[_\w+]*)\(([^\)]*)\)')
        self.args_regexp = re.compile(r'(?:[^\s,"]|"(?:\\.|[^"])*")+')

        # create completer
        self.completer = QtWidgets.QCompleter(self)
        self.completer.setCompletionMode(QtWidgets.QCompleter.PopupCompletion)
        self.completer.setCompletionRole(QtCore.Qt.DisplayRole)
        self.completer.setCompletionColumn(0)
        self.completer.setCaseSensitivity(QtCore.Qt.CaseInsensitive)
        self.textCommandInput.setCompleter(self.completer)
        self._update_client_list()

        # create widget for popup
        table_view = QtWidgets.QTableView(self)
        self.completer.setPopup(table_view)
        table_view.verticalHeader().hide()
        table_view.setShowGrid(False)
        table_view.setMinimumHeight(50)
        table_view.horizontalHeader().hide()
        table_view.horizontalHeader().setStretchLastSection(False)
        table_view.horizontalHeader().setSectionResizeMode(0, QtWidgets.QHeaderView.ResizeToContents)
        table_view.horizontalHeader().setSectionResizeMode(1, QtWidgets.QHeaderView.ResizeToContents)
        table_view.horizontalHeader().setSectionResizeMode(2, QtWidgets.QHeaderView.Stretch)
        table_view.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectRows)

        # subscribe to events
        self.comm.register_event(LogEvent, self.process_log_entry)
        self.comm.register_event(ClientConnectedEvent, lambda x, y: self.client_list_changed.emit())
        self.comm.register_event(ClientDisconnectedEvent, lambda x, y: self.client_list_changed.emit())

        # signals/slots
        # self.add_log.connect(self.textLogs.append)
        self.add_command_log.connect(self.textCommandLog.append)
        self.textCommandInput.commandExecuted.connect(self.execute_command)
        self.client_list_changed.connect(self._update_client_list)
        self.textCommandInput.textChanged.connect(self._update_docs)

        # timer for showing variables
        self.tableVariables.setColumnCount(2)
        self.tableVariables.setHorizontalHeaderLabels(['Key', 'Value'])
        self._variables_timer = QtCore.QTimer()
        self._variables_timer.timeout.connect(self._update_variables)
        self._variables_timer.start(1000)

    @QtCore.pyqtSlot()
    def _update_variables(self):
        self.tableVariables.setRowCount(len(self.comm.variables))
        for i, key in enumerate(self.comm.variables.keys()):
            self.tableVariables.setItem(i, 0, QtWidgets.QTableWidgetItem(key))
            self.tableVariables.setItem(i, 1, QtWidgets.QTableWidgetItem(str(self.comm.variables[key])))

    def _resize_log_table(self):
        # resize columns
        self.tableLog.horizontalHeader().resizeSections(QtWidgets.QHeaderView.ResizeToContents)
        self.tableLog.horizontalHeader().setSectionResizeMode(4, QtWidgets.QHeaderView.ResizeToContents)
        # this is a one-time shot, so unconnect signal
        self.log_model.rowsInserted.disconnect(self._resize_log_table)

    def _update_client_list(self, *args):
        # add all clients to list
        self.listLogClients.clear()
        for c in self.comm.clients:
            name = c[:c.find('@')]
            item = QtWidgets.QListWidgetItem(name)
            item.setCheckState(QtCore.Qt.Checked)
            item.setForeground(QtGui.QColor(Color(pick_for=name).hex))
            self.listLogClients.addItem(item)

        # create model for commands
        self.command_model = CommandModel(self.comm)
        self.completer.setModel(self.command_model)

    def _log_client_changed(self, item: QtWidgets.QListWidgetItem):
        # update proxy
        self.log_proxy.filter_source(str(item.text()), item.checkState() == QtCore.Qt.Checked)

    def process_log_entry(self, entry: LogEvent, sender: str) -> bool:
        # date
        time = Time(entry.time, format='unix')

        # format sender
        sender = str(sender)
        sender = sender[:sender.index('@')]

        # define new row and emit
        row = [time.iso.split()[1],
               str(sender),
               entry.level,
               '%s:%d' % (os.path.basename(entry.filename), entry.line),
               entry.message]
        self.add_log.emit(row)
        return True

    def _add_command_log(self, msg, color=None):
        if color is not None:
            msg = '<span style="color:%s;">%s</span>' % (color, msg)
        self.add_command_log.emit(msg)

    def execute_command(self, command):
        self._add_command_log('$ ' + command, 'blue')

        # parse command
        m1 = self.command_regexp.match(command)
        if not m1:
            self._add_command_log('Invalid syntax', 'red')
            return
        module = m1.group(1)
        command = m1.group(2)

        # get module
        mod = self.comm[module]

        # split arguments, if any
        args = [a[1:-1] if a[0] == a[-1] == '"' else a for a in self.args_regexp.findall(m1.group(3))]

        # execute command in new thread
        thread = Thread(target=self._execute_command_async, args=(mod, command, *args),
                        name=module + '.' + command)
        thread.start()

    def _execute_command_async(self, mod, command, *args):
        # execute command
        try:
            response = mod.execute_safely(command, *args)
        except ValueError as e:
            self._add_command_log('Invalid parameter: %s' % str(e), 'red')
            return
        except RemoteException as e:
            if e:
                self._add_command_log('Remote error: %s' % str(e), 'red')
            else:
                self._add_command_log('Unknown Remote error', 'red')
            return

        # log response
        self._add_command_log(pprint.pformat(response))

    def _update_docs(self):
        # get current input
        cmd = str(self.textCommandInput.text())
        if '(' in cmd:
            cmd = cmd[:cmd.index('(')]

        # get documentation
        doc = self.command_model.doc(cmd)
        if not doc:
            self.textCommandHelp.clear()
            return

        # emit doc
        self.textCommandHelp.setText(doc)


class CommandModel(QtCore.QAbstractTableModel):
    def __init__(self, comm, *args, **kwargs):
        QtCore.QAbstractTableModel.__init__(self, *args, **kwargs)

        # create model
        self.commands = []
        for c in comm.clients:
            # get proxy
            client_name = c[:c.find('@')]
            proxy = comm[c]

            # loop commands
            for method in proxy.method_names:
                # get name
                name = '%s.%s' % (client_name, method)

                # get signature
                params = []
                for param_name, param in proxy.signature(method).parameters.items():
                    if param_name not in ['self', 'args', 'kwargs']:
                        # parameter name itself
                        arg = param_name

                        # go a type?
                        if param.annotation != inspect.Parameter.empty:
                            arg += ': ' + param.annotation.__name__

                        # default value?
                        if param.default != inspect.Parameter.empty:
                            arg += ' = ' + str(param.default)

                        params.append(arg)

                # get first line of documentation
                doc = proxy.interface_method(method).__doc__
                short_doc = doc.split('\n')[0]

                # append to list
                self.commands.append((name, '(' + ', '.join(params) + ')', short_doc, doc))

        # sort
        self.commands.sort(key=lambda m: m[0])

    def doc(self, command):
        for c in self.commands:
            if c[0] == command:
                return c[3]
        return None

    def rowCount(self, parent=None, *args, **kwargs):
        return len(self.commands)

    def columnCount(self, parent=None, *args, **kwargs):
        return 3

    def data(self, index: QtCore.QModelIndex, role=None):
        if role == QtCore.Qt.DisplayRole:
            return self.commands[index.row()][index.column()]


if __name__ == '__main__':
    # logger
    logging.basicConfig(level=logging.INFO, format='%(asctime)s [%(levelname)s] %(filename)s:%(lineno)d %(message)s')

    # argparse
    parser = argparse.ArgumentParser()
    parser.add_argument('jid', type=str, help='Jabber ID to connect as')
    parser.add_argument('password', type=str, help='Password for given JID')
    parser.add_argument('-s', '--server', type=str, help='Server to connect to')
    args = parser.parse_args()

    # create object and open it
    comm = XmppComm(jid=args.jid, password=args.password, server=args.server)
    comm.open()

    # create app
    app = QtWidgets.QApplication(sys.argv)

    # create and show window
    window = Supervisor(comm)
    window.show()

    # run
    app.exec()

    # close xmpp
    comm.close()
